schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  hello: String!
  groups(ids: [IntID!]!): [Group!]!
  adminUsers: AdminUserQueries!
  currentUser: User
  users(ids: [IntID!]!): [User!]!
  adminActions: AdminActionQueries!
  projects(ids: [IntID!]!): [Project!]!
  adminContent: AdminContentQueries!
  content(ids: [IntID!]!): [Content!]!
  topics(ids: [IntID!]!): [Topic!]!
  domains(ids: [IntID!]!): [Domain!]!
  adminDomain: AdminDomainQueries!
  kcs(ids: [IntID!]!): [KC!]!
  adminProjects: AdminProjectsQueries!
  hello2: String!
}

type Mutation {
  hello: String!
  adminUsers: AdminUserMutations!
  action(data: ActionInput!): Void
  adminContent: AdminContentMutations!
  adminDomain: AdminDomainMutations!
  adminProjects: AdminProjectsMutations!
}

type Subscription {
  hello: String!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""
Integers that will have a value of 0 or more.
"""
scalar NonNegativeInt

"""
Represents NULL values
"""
scalar Void

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress

"""
ID that parses as non-negative integer, serializes to string, and can be passed as string or number
"""
scalar IntID

type Group {
  id: IntID!
  code: String!
  label: String!
  users: [User!]!
  tags: [String!]!
  flags: GroupFlags!
  createdAt: DateTime!
  updatedAt: DateTime!
  projectsIds: [IntID!]!
  projects: [Project!]!
}

type GroupFlags {
  id: IntID!
  readProjectActions: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input GroupFlagsInput {
  readProjectActions: Boolean!
}

input CreateGroupInput {
  code: String!
  label: String!
  tags: [String!]!
  projectIds: [IntID!]!
  flags: GroupFlagsInput
}

input UpdateGroupInput {
  id: IntID!
  code: String!
  label: String!
  tags: [String!]!
  projectIds: [IntID!]!
  flags: GroupFlagsInput
}

type GroupsConnection implements Connection {
  nodes: [Group!]!
  pageInfo: PageInfo!
}

input AdminGroupsFilter {
  tags: [String!]
}

enum UserRole {
  ADMIN
  USER
}

type User {
  id: IntID!
  enabled: Boolean!
  email: String!
  name: String
  locked: Boolean!
  active: Boolean!
  lastOnline: DateTime
  tags: [String!]!
  role: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
  groups: [Group!]!
  projectsIds: [IntID!]!
  projects: [Project!]!
}

type UsersConnection implements Connection {
  nodes: [User!]!
  pageInfo: PageInfo!
}

input AdminUsersFilter {
  tags: [String!]
}

type AdminUserQueries {
  allUsers(
    pagination: CursorConnectionArgs!
    filters: AdminUsersFilter
  ): UsersConnection!
  allGroups(
    pagination: CursorConnectionArgs!
    filters: AdminGroupsFilter
  ): GroupsConnection!
}

input UpdateUserInput {
  id: IntID!
  name: String
  role: UserRole!
  locked: Boolean!
  projectIds: [IntID!]!
  tags: [String!]!
}

type AdminUserMutations {
  """
  Upsert specified users with specified project
  """
  upsertUsersWithProjects(
    emails: [EmailAddress!]!
    projectsIds: [IntID!]!
  ): [User!]!
  updateUser(data: UpdateUserInput!): User!
  setUserGroups(usersEmails: [EmailAddress!]!, groupIds: [IntID!]!): [Group!]!
  createGroup(data: CreateGroupInput!): Group!
  updateGroup(data: UpdateGroupInput!): Group!
  setProjectsToUsers(projectIds: [IntID!]!, userIds: [IntID!]!): [User!]!
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

interface Node {
  id: IntID!
}

interface Connection {
  pageInfo: PageInfo!
}

input CursorConnectionArgs {
  first: NonNegativeInt
  after: IntID
  last: NonNegativeInt
  before: IntID
}

type ActionVerb {
  id: IntID!
  name: String!
}

type Content {
  id: IntID!
  code: String!
  label: String!
  description: String!
  binaryBase64: String
  binaryFilename: String
  json: JSONObject
  url: String
  sortIndex: Int
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  topics: [Topic!]!
  kcs: [KC!]!
  project: Project!
}

type KC {
  id: IntID!
  code: String!
  label: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  domain: Domain!
  topics: [Topic!]!
}

type Domain {
  id: IntID!
  code: String!
  label: String!
  topics: [Topic!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  kcs: [KC!]!
  projects: [Project!]!
}

type Topic {
  id: IntID!
  content: [Content!]!
  code: String!
  label: String!
  sortIndex: Int
  parent: Topic
  childrens: [Topic!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  kcs: [KC!]!
  project: Project!
}

input ActionInput {
  contentID: ID
  topicID: ID
  kcsIDs: [ID!]
  stepID: ID
  hintID: ID
  amount: Float
  detail: String
  extra: JSONObject
  verbName: String!
  timestamp: Timestamp!
  projectId: IntID!
  result: Float
}

type Action {
  id: IntID!
  verb: ActionVerb!
  timestamp: Timestamp!
  result: Float
  user: User
  content: Content
  topic: Topic
  kcs: [KC!]!
  stepID: ID
  hintID: ID
  amount: Float
  detail: String
  extra: JSONObject
  createdAt: DateTime!
}

type ActionsConnection implements Connection {
  nodes: [Action!]!
  pageInfo: PageInfo!
}

type ActionsVerbsConnection implements Connection {
  nodes: [ActionVerb!]!
  pageInfo: PageInfo!
}

input AdminActionsFilter {
  verbNames: [String!]
  users: [IntID!]
  kcs: [IntID!]
  content: [IntID!]
  topics: [IntID!]
  projects: [IntID!]
  startDate: DateTime
  endDate: DateTime
}

type AdminActionQueries {
  allActions(
    pagination: CursorConnectionArgs!
    filters: AdminActionsFilter
  ): ActionsConnection!
  allActionsVerbs(pagination: CursorConnectionArgs!): ActionsVerbsConnection!
}

type Project {
  id: IntID!
  actions(
    pagination: CursorConnectionArgs!
    filters: ProjectActionsFilter
  ): ActionsConnection!
  domains: [Domain!]!
  code: String!
  label: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProjectActionsFilter {
  verbNames: [String!]
  users: [IntID!]
  kcs: [IntID!]
  content: [IntID!]
  topics: [IntID!]
  startDate: DateTime
  endDate: DateTime
}

input CreateContent {
  description: String!
  code: String!
  label: String!
  projectId: IntID!
  binaryBase64: String
  binaryFilename: String
  json: JSONObject
  url: URL
  topics: [IntID!]!
  kcs: [IntID!]!
  tags: [String!]!
}

input UpdateContent {
  id: IntID!
  description: String!
  code: String!
  label: String!
  projectId: IntID!
  binaryBase64: String
  binaryFilename: String
  json: JSONObject
  url: URL
  topics: [IntID!]!
  kcs: [IntID!]!
  tags: [String!]!
}

type ContentConnection implements Connection {
  nodes: [Content!]!
  pageInfo: PageInfo!
}

type AdminContentMutations {
  createContent(data: CreateContent!): Content!
  updateContent(data: UpdateContent!): Content!
}

input AdminContentFilter {
  tags: [String!]
  projects: [IntID!]
}

type AdminContentQueries {
  allContent(
    pagination: CursorConnectionArgs!
    filters: AdminContentFilter
  ): ContentConnection!
}

type TopicsConnection implements Connection {
  nodes: [Topic!]!
  pageInfo: PageInfo!
}

type DomainsConnection implements Connection {
  nodes: [Domain!]!
  pageInfo: PageInfo!
}

input AdminDomainsFilter {
  projects: [IntID!]
}

input AdminTopicsFilter {
  projects: [IntID!]
}

type AdminDomainQueries {
  allTopics(
    pagination: CursorConnectionArgs!
    filters: AdminTopicsFilter
  ): TopicsConnection!
  allDomains(
    pagination: CursorConnectionArgs!
    filters: AdminDomainsFilter
  ): DomainsConnection!
  allKCs(
    pagination: CursorConnectionArgs!
    filters: AdminKCsFilter
  ): KCsConnection!
}

input CreateDomain {
  code: String!
  label: String!
  projectsIds: [IntID!]!
}

input UpdateDomain {
  id: IntID!
  code: String!
  label: String!
}

input CreateTopic {
  code: String!
  label: String!
  parentTopicId: IntID
  projectId: IntID!
  contentIds: [IntID!]!
  sortIndex: Int
}

input UpdateTopic {
  id: IntID!
  code: String!
  label: String!
  parentTopicId: IntID
  contentIds: [IntID!]!
  sortIndex: Int
}

type AdminDomainMutations {
  createDomain(input: CreateDomain!): Domain!
  updateDomain(input: UpdateDomain!): Domain!
  createTopic(input: CreateTopic!): Topic!
  updateTopic(input: UpdateTopic!): Topic!
  createKC(data: CreateKCInput!): KC!
  updateKC(data: UpdateKCInput!): KC!
}

type KCsConnection implements Connection {
  nodes: [KC!]!
  pageInfo: PageInfo!
}

input AdminKCsFilter {
  domains: [IntID!]
  projects: [IntID!]
}

input CreateKCInput {
  code: String!
  label: String!
  domainId: IntID!
}

input UpdateKCInput {
  id: IntID!
  code: String!
  label: String!
}

type ProjectsConnection implements Connection {
  nodes: [Project!]!
  pageInfo: PageInfo!
}

type AdminProjectsQueries {
  allProjects(pagination: CursorConnectionArgs!): ProjectsConnection!
}

input CreateProject {
  code: String!
  label: String!
  domains: [IntID!]!
}

input UpdateProject {
  id: IntID!
  code: String!
  label: String!
  domains: [IntID!]!
}

type AdminProjectsMutations {
  createProject(data: CreateProject!): Project!
  updateProject(data: UpdateProject!): Project!
}
