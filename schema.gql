schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  hello: String!
  groups(ids: [IntID!]!): [Group!]!
  adminUsers: AdminUserQueries!
  currentUser: User
  users(ids: [IntID!]!): [User!]!
  adminActions: AdminActionQueries!
  adminContent: AdminContentQueries!
  domains(ids: [IntID!]!): [Domain!]!
  topics(ids: [IntID!]!): [Topic!]!
  content(ids: [IntID!]!): [Content!]!
  adminDomain: AdminDomainQueries!
  projects(ids: [IntID!]!): [Project!]!
  adminProjects: AdminProjectsQueries!
  hello2: String!
}

type Mutation {
  hello: String!
  adminUsers: AdminUserMutations!
  action(data: ActionInput!): Void
  adminContent: AdminContentMutations!
  adminDomain: AdminDomainMutations!
  adminProjects: AdminProjectsMutations!
}

type Subscription {
  hello: String!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""
Integers that will have a value of 0 or more.
"""
scalar NonNegativeInt

"""
Represents NULL values
"""
scalar Void

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""
ID that parses as non-negative integer, serializes to string, and can be passed as string or number
"""
scalar IntID

type Group {
  id: IntID!
  code: String!
  label: String!
  users: [User!]!
  projectsIds: [IntID!]!
  projects: [Project!]!
}

input CreateGroupInput {
  code: String!
  label: String!
  projectIds: [IntID!]!
}

input UpdateGroupInput {
  id: IntID!
  code: String!
  label: String!
  projectIds: [IntID!]!
}

type GroupsConnection implements Connection {
  nodes: [Group!]!
  pageInfo: PageInfo!
}

enum UserRole {
  ADMIN
  USER
}

type User {
  id: IntID!
  enabled: Boolean!
  email: String!
  name: String
  locked: Boolean!
  active: Boolean!
  lastOnline: DateTime
  role: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
  groups: [Group!]!
  projectsIds: [IntID!]!
  projects: [Project!]!
}

type UsersConnection {
  nodes: [User!]!
  pageInfo: PageInfo!
}

type AdminUserQueries {
  allUsers(pagination: CursorConnectionArgs!): UsersConnection!
  allGroups(pagination: CursorConnectionArgs!): GroupsConnection!
}

input UpsertUserInput {
  email: String!
  name: String
}

input UpdateUserInput {
  id: IntID!
  role: UserRole!
  locked: Boolean!
}

type AdminUserMutations {
  """
  Upsert specified users, if user with specified email already exists, updates it with the specified name
  """
  upsertUsers(data: [UpsertUserInput!]!): [User!]!
  updateUser(data: UpdateUserInput!): User!
  setUserGroups(userIds: [IntID!]!, groupIds: [IntID!]!): [User!]!
  createGroup(data: CreateGroupInput!): Group!
  updateGroup(data: UpdateGroupInput!): Group!
  setProjectsToUsers(projectIds: [IntID!]!, userIds: [IntID!]!): [User!]!
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

interface Node {
  id: IntID!
}

interface Connection {
  pageInfo: PageInfo!
}

input CursorConnectionArgs {
  first: NonNegativeInt
  after: IntID
  last: NonNegativeInt
  before: IntID
}

type ActionVerb {
  id: IntID!
  name: String!
}

type Content {
  id: IntID!
  description: String!
  binaryBase64: String
  json: JSONObject
  url: String
  createdAt: DateTime!
  updatedAt: DateTime!
  domain: Domain!
  project: Project!
}

type Domain {
  id: IntID!
  content(pagination: CursorConnectionArgs!): ContentConnection!
  code: String!
  label: String!
  topics: [Topic!]!
  kcs: [KC!]!
  project: Project!
}

type Topic {
  id: IntID!
  content(pagination: CursorConnectionArgs!): ContentConnection!
  code: String!
  label: String!
  domain: Domain!
  parent: Topic
  childrens: [Topic!]!
  kcs: [KC!]!
  project: Project!
}

type ActionActivity {
  id: IntID!
  content: Content
  topic: Topic
  stepID: ID
  hintID: ID
  amount: Float
  detail: String
  extra: JSONObject
}

input ActionActivityInput {
  contentID: IntID
  topicID: IntID
  stepID: ID
  hintID: ID
  amount: Float
  detail: String
  extra: JSONObject
}

input ActionInput {
  activity: ActionActivityInput!
  verbName: String!
  timestamp: Timestamp!
  projectId: IntID!
}

type Action {
  id: IntID!
  verb: ActionVerb!
  activity: ActionActivity!
  timestamp: Timestamp!
  result: Float
  user: User
}

type ActionsConnection {
  nodes: [Action!]!
  pageInfo: PageInfo!
}

type AdminActionQueries {
  allActions(pagination: CursorConnectionArgs!): ActionsConnection!
}

input CreateContent {
  description: String!
  projectId: IntID!
  domainId: IntID!
  topicId: IntID
  binaryBase64: String
  json: JSONObject
  url: String
}

type ContentConnection implements Connection {
  nodes: [Content!]!
  pageInfo: PageInfo!
}

type AdminContentMutations {
  createContent(data: CreateContent!): Content!
}

type AdminContentQueries {
  allContent(pagination: CursorConnectionArgs!): ContentConnection!
}

type TopicsConnection implements Connection {
  nodes: [Topic!]!
  pageInfo: PageInfo!
}

type DomainsConnection implements Connection {
  nodes: [Domain!]!
  pageInfo: PageInfo!
}

type AdminDomainQueries {
  allTopics(pagination: CursorConnectionArgs!): TopicsConnection!
  allDomains(pagination: CursorConnectionArgs!): DomainsConnection!
  allKCs(pagination: CursorConnectionArgs!): KCsConnection!
}

input CreateDomain {
  code: String!
  label: String!
  projectId: IntID!
}

input UpdateDomain {
  id: IntID!
  label: String!
}

input CreateTopic {
  code: String!
  label: String!
  parentTopicId: IntID
  domainId: IntID!
  projectId: IntID!
}

input UpdateTopic {
  id: IntID!
  code: String!
  label: String!
  parentTopicId: IntID
  domainId: IntID!
  projectId: IntID!
}

type AdminDomainMutations {
  createDomain(input: CreateDomain!): Domain!
  updateDomain(input: UpdateDomain!): Domain!
  createTopic(input: CreateTopic!): Topic!
  updateTopic(input: UpdateTopic!): Topic!
  createKC(data: CreateKCInput!): KC!
  updateKC(data: UpdateKCInput!): KC!
}

type KC {
  id: IntID!
  code: String!
  label: String!
  domain: Domain!
  topics: [Topic!]!
}

type KCsConnection implements Connection {
  nodes: [KC!]!
  pageInfo: PageInfo!
}

input CreateKCInput {
  code: String!
  label: String!
  domainId: IntID!
}

input UpdateKCInput {
  id: IntID!
  code: String!
  label: String!
}

type Project {
  id: IntID!
  domains: [Domain!]!
  code: String!
  label: String!
}

type ProjectsConnection implements Connection {
  nodes: [Project!]!
  pageInfo: PageInfo!
}

type AdminProjectsQueries {
  allProjects(pagination: CursorConnectionArgs!): ProjectsConnection!
}

input CreateProject {
  code: String!
  label: String!
}

input UpdateProject {
  id: IntID!
  code: String!
  label: String!
}

type AdminProjectsMutations {
  createProject(data: CreateProject!): Project!
  updateProject(data: UpdateProject!): Project!
}
