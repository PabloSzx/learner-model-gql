schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"""
User-emitted actions related to system, data mainly used for logging and modeling purposes
"""
type Action {
  """
  Arbitrary numeric amount
  """
  amount: Float
  """
  Related content
  """
  content: Content
  """
  Timestamp of the action, set by the database on row creation
  """
  createdAt: DateTime!
  """
  Arbitrary string content detail
  """
  detail: String
  """
  Arbitrary JSON object data
  """
  extra: JSONObject
  """
  Arbitrary hint identifier
  """
  hintID: ID
  id: IntID!
  """
  Related KCs
  """
  kcs: [KC!]!
  """
  Arbitrary numeric result
  """
  result: Float
  """
  Arbitrary step identifier
  """
  stepID: ID
  """
  Timestamp of the action, set by the action emitter
  """
  timestamp: Timestamp!
  """
  Related topic
  """
  topic: Topic
  """
  User that emitted the action
  """
  user: User
  """
  Type of action
  """
  verb: ActionVerb!
}

input ActionInput {
  """
  Arbitrary numeric amount
  """
  amount: Float
  """
  Content identifier

  If it's numeric, it points to the "id" property of the content, otherwise, it points to the "code" property.

  Validation of content presence/authorization is made before confirming action
  """
  contentID: ID
  """
  Arbitrary string content detail
  """
  detail: String
  """
  Arbitrary JSON object data
  """
  extra: JSONObject
  """
  Arbitrary hint identifier
  """
  hintID: ID
  """
  KCs identifiers

  If it's numeric, it points to the "id" property of the content, otherwise, it points to the "code" property.

  Validation of kc presence/authorization is made before confirming action
  """
  kcsIDs: [ID!]
  """
  Identifier of project related to action.

  It's verified based on authenticated user, and attached validated ids are validated against the specified project
  """
  projectId: IntID!
  """
  Arbitrary numeric result
  """
  result: Float
  """
  Arbitrary step identifier
  """
  stepID: ID
  """
  Timestamp of the action.

  Format in number of milliseconds elapsed since January 1, 1970 00:00:00 UTC
  """
  timestamp: Timestamp!
  """
  Topic identifier

  If it's numeric, it points to the "id" property of the content, otherwise, it points to the "code" property.

  Validation of topic presence/authorization is made before confirming action
  """
  topicID: ID
  """
  Type of action, if specified verb doesn't exist, it's automatically created
  """
  verbName: String!
}

"""
Action Verb

Main action categorization system
"""
type ActionVerb {
  id: IntID!
  """
  Name of the verb
  """
  name: String!
}

type ActionsConnection implements Connection {
  """
  Nodes of the current page
  """
  nodes: [Action!]!
  """
  Pagination related information
  """
  pageInfo: PageInfo!
}

type ActionsVerbsConnection implements Connection {
  """
  Nodes of the current page
  """
  nodes: [ActionVerb!]!
  """
  Pagination related information
  """
  pageInfo: PageInfo!
}

type AdminActionQueries {
  """
  [ADMIN] Get all the actions currently in the system

  Pagination parameters are mandatory, but filters and orderBy are optional, and therefore the search can be customized.
  """
  allActions(
    filters: AdminActionsFilter
    orderBy: AdminActionsOrderBy
    pagination: CursorConnectionArgs!
  ): ActionsConnection!
  """
  [ADMIN] Get all the action's verbs currently in the system
  """
  allActionsVerbs(pagination: CursorConnectionArgs!): ActionsVerbsConnection!
}

input AdminActionsFilter {
  """
  Filter by the specified content

  If action's content matches any of the specified content, the action is included
  """
  content: [IntID!]
  """
  Filter by the specified end date

  If action's timestamp is before the specified date, the action is included
  """
  endDate: DateTime
  """
  Filter by the specified KCs

  If any of the action's KCs matches any of the specified KCs, the action is included
  """
  kcs: [IntID!]
  """
  Filter by the specified projects

  If action's project matches any of the specified projects, the action is included
  """
  projects: [IntID!]
  """
  Filter by the specified starting date

  If action's timestamp is after the specified date, the action is included
  """
  startDate: DateTime
  """
  Filter by the specified topics

  If action's topic matches any of the specified topics, the action is included
  """
  topics: [IntID!]
  """
  Filter by the specified users

  If action's user matches any of the specified users, the action is included
  """
  users: [IntID!]
  """
  Filter by the specified verbs

  If action's verb matches any of the specified verbs, the action is included
  """
  verbNames: [String!]
}

input AdminActionsOrderBy {
  """
  Order the actions ascendingly or descendingly

  Following the cursor pagination's nature, ordering by "id" tends to follow the action creation date, but it can't be guaranteed

  By default the actions are ordered descendingly, showing the newer actions first
  """
  id: ORDER_BY = DESC
}

input AdminContentFilter {
  projects: [IntID!]
  tags: [String!]
}

type AdminContentMutations {
  createContent(data: CreateContent!): Content!
  updateContent(data: UpdateContent!): Content!
}

type AdminContentQueries {
  allContent(
    filters: AdminContentFilter
    pagination: CursorConnectionArgs!
  ): ContentConnection!
}

type AdminDomainMutations {
  createDomain(input: CreateDomain!): Domain!
  createKC(data: CreateKCInput!): KC!
  createTopic(input: CreateTopic!): Topic!
  updateDomain(input: UpdateDomain!): Domain!
  updateKC(data: UpdateKCInput!): KC!
  updateTopic(input: UpdateTopic!): Topic!
}

type AdminDomainQueries {
  allDomains(
    filters: AdminDomainsFilter
    pagination: CursorConnectionArgs!
  ): DomainsConnection!
  allKCs(
    filters: AdminKCsFilter
    pagination: CursorConnectionArgs!
  ): KCsConnection!
  allTopics(
    filters: AdminTopicsFilter
    pagination: CursorConnectionArgs!
  ): TopicsConnection!
}

input AdminDomainsFilter {
  projects: [IntID!]
}

input AdminGroupsFilter {
  tags: [String!]
}

input AdminKCsFilter {
  domains: [IntID!]
  projects: [IntID!]
}

type AdminProjectsMutations {
  createProject(data: CreateProject!): Project!
  updateProject(data: UpdateProject!): Project!
}

type AdminProjectsQueries {
  allProjects(pagination: CursorConnectionArgs!): ProjectsConnection!
}

type AdminStateQueries {
  allModelStateCreators(
    pagination: CursorConnectionArgs!
  ): ModelStateCreatorConnection!
  allModelStateTypes(
    pagination: CursorConnectionArgs!
  ): ModelStateTypeConnection!
  allModelStates(input: ModelStateConnectionInput!): ModelStateConnection!
}

input AdminTopicsFilter {
  projects: [IntID!]
}

type AdminUserMutations {
  createGroup(data: CreateGroupInput!): Group!
  setProjectsToUsers(projectIds: [IntID!]!, userIds: [IntID!]!): [User!]!
  setUserGroups(groupIds: [IntID!]!, usersEmails: [EmailAddress!]!): [Group!]!
  updateGroup(data: UpdateGroupInput!): Group!
  updateUser(data: UpdateUserInput!): User!
  """
  Upsert specified users with specified project
  """
  upsertUsersWithProjects(
    emails: [EmailAddress!]!
    projectsIds: [IntID!]!
  ): [User!]!
}

type AdminUserQueries {
  allGroups(
    filters: AdminGroupsFilter
    pagination: CursorConnectionArgs!
  ): GroupsConnection!
  allUsers(
    filters: AdminUsersFilter
    pagination: CursorConnectionArgs!
  ): UsersConnection!
}

input AdminUsersFilter {
  tags: [String!]
}

interface Connection {
  pageInfo: PageInfo!
}

type Content {
  binaryBase64: String
  binaryFilename: String
  code: String!
  createdAt: DateTime!
  description: String!
  id: IntID!
  json: JSONObject
  kcs: [KC!]!
  label: String!
  project: Project!
  sortIndex: Int
  tags: [String!]!
  topics: [Topic!]!
  updatedAt: DateTime!
  url: String
}

type ContentConnection implements Connection {
  nodes: [Content!]!
  pageInfo: PageInfo!
}

input CreateContent {
  binaryBase64: String
  binaryFilename: String
  code: String!
  description: String!
  json: JSONObject
  kcs: [IntID!]!
  label: String!
  projectId: IntID!
  tags: [String!]!
  topics: [IntID!]!
  url: URL
}

input CreateDomain {
  code: String!
  label: String!
  projectsIds: [IntID!]!
}

input CreateGroupInput {
  code: String!
  flags: GroupFlagsInput
  label: String!
  projectIds: [IntID!]!
  tags: [String!]!
}

input CreateKCInput {
  code: String!
  domainId: IntID!
  label: String!
}

input CreateProject {
  code: String!
  domains: [IntID!]!
  label: String!
}

input CreateTopic {
  code: String!
  contentIds: [IntID!]!
  label: String!
  parentTopicId: IntID
  projectId: IntID!
  sortIndex: Int
  tags: [String!]!
}

input CursorConnectionArgs {
  after: IntID
  before: IntID
  first: NonNegativeInt
  last: NonNegativeInt
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type Domain {
  code: String!
  createdAt: DateTime!
  id: IntID!
  kcs: [KC!]!
  label: String!
  modelStates(input: ModelStateConnectionInput!): ModelStateConnection!
  projects: [Project!]!
  updatedAt: DateTime!
}

type DomainsConnection implements Connection {
  nodes: [Domain!]!
  pageInfo: PageInfo!
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress

type Group {
  code: String!
  createdAt: DateTime!
  flags: GroupFlags!
  id: IntID!
  label: String!
  projects: [Project!]!
  projectsIds: [IntID!]!
  tags: [String!]!
  updatedAt: DateTime!
  users: [User!]!
}

type GroupFlags {
  createdAt: DateTime!
  id: IntID!
  readProjectActions: Boolean!
  readProjectModelStates: Boolean!
  updatedAt: DateTime!
}

input GroupFlagsInput {
  readProjectActions: Boolean!
  readProjectModelStates: Boolean!
}

type GroupsConnection implements Connection {
  nodes: [Group!]!
  pageInfo: PageInfo!
}

"""
ID that parses as non-negative integer, serializes to string, and can be passed as string or number
"""
scalar IntID

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type KC {
  code: String!
  createdAt: DateTime!
  domain: Domain!
  id: IntID!
  label: String!
  topics: [Topic!]!
  updatedAt: DateTime!
}

type KCsConnection implements Connection {
  nodes: [KC!]!
  pageInfo: PageInfo!
}

type ModelState {
  createdAt: DateTime!
  creator: String!
  domain: Domain!
  id: IntID!
  json: JSON!
  type: String
  updatedAt: DateTime!
  user: User!
}

type ModelStateConnection implements Connection {
  nodes: [ModelState!]!
  pageInfo: PageInfo!
}

input ModelStateConnectionInput {
  filters: ModelStateFilter
  orderBy: ModelStateOrderBy
  pagination: CursorConnectionArgs!
}

type ModelStateCreator {
  createdAt: DateTime!
  id: IntID!
  name: String!
  updatedAt: DateTime!
}

type ModelStateCreatorConnection implements Connection {
  nodes: [ModelStateCreator!]!
  pageInfo: PageInfo!
}

input ModelStateFilter {
  creators: [String!]
  type: [String!]
}

input ModelStateOrderBy {
  id: ORDER_BY = DESC
}

type ModelStateType {
  createdAt: DateTime!
  id: IntID!
  name: String!
  updatedAt: DateTime!
}

type ModelStateTypeConnection implements Connection {
  nodes: [ModelStateType!]!
  pageInfo: PageInfo!
}

type Mutation {
  """
  Report an action to the modeling service

  - User authentication is required
  - Authenticated user has to be associated with specified project
  """
  action(data: ActionInput!): Void
  adminContent: AdminContentMutations!
  adminDomain: AdminDomainMutations!
  adminProjects: AdminProjectsMutations!
  adminUsers: AdminUserMutations!
  hello: String!
}

interface Node {
  id: IntID!
}

"""
Integers that will have a value of 0 or more.
"""
scalar NonNegativeInt

enum ORDER_BY {
  ASC
  DESC
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Project {
  actions(
    filters: ProjectActionsFilter
    pagination: CursorConnectionArgs!
  ): ActionsConnection!
  code: String!
  content(
    filters: ProjectContentFilter
    pagination: CursorConnectionArgs!
  ): ContentConnection!
  createdAt: DateTime!
  domains: [Domain!]!
  id: IntID!
  label: String!
  topics: [Topic!]!
  updatedAt: DateTime!
}

input ProjectActionsFilter {
  content: [IntID!]
  endDate: DateTime
  kcs: [IntID!]
  startDate: DateTime
  topics: [IntID!]
  users: [IntID!]
  verbNames: [String!]
}

input ProjectContentFilter {
  createdEndDate: DateTime
  createdStartDate: DateTime
  kcsIds: [IntID!]
  tags: [String!]
  topicsIds: [IntID!]
  updatedEndDate: DateTime
  updatedStartDate: DateTime
}

type ProjectsConnection implements Connection {
  nodes: [Project!]!
  pageInfo: PageInfo!
}

type Query {
  """
  [ADMIN] Admin related actions, only authenticated users with the role "ADMIN" can access
  """
  adminActions: AdminActionQueries!
  adminContent: AdminContentQueries!
  adminDomain: AdminDomainQueries!
  """
  [ADMIN] Project related administration queries
  """
  adminProjects: AdminProjectsQueries!
  adminState: AdminStateQueries!
  adminUsers: AdminUserQueries!
  content(ids: [IntID!]!): [Content!]!
  """
  Get specified content by "code".

  - If user is not authenticated it throws.
  - If authenticated user has no permissions on the specified project it returns NULL.
  """
  contentByCode(code: String!): Content
  currentUser: User
  domains(ids: [IntID!]!): [Domain!]!
  groups(ids: [IntID!]!): [Group!]!
  hello: String!
  kcs(ids: [IntID!]!): [KC!]!
  """
  Get specified project by either "id" or "code".

  - If user is not authenticated it will always return NULL.
  - If authenticated user has no permissions on the specified project it returns NULL.
  """
  project(code: String, id: IntID): Project
  projects(ids: [IntID!]!): [Project!]!
  topicByCode(code: String!): Topic
  topics(ids: [IntID!]!): [Topic!]!
  users(ids: [IntID!]!): [User!]!
}

type Subscription {
  hello: String!
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type Topic {
  childrens: [Topic!]!
  code: String!
  content: [Content!]!
  createdAt: DateTime!
  id: IntID!
  kcs: [KC!]!
  label: String!
  parent: Topic
  project: Project!
  sortIndex: Int
  tags: [String!]!
  updatedAt: DateTime!
}

type TopicsConnection implements Connection {
  nodes: [Topic!]!
  pageInfo: PageInfo!
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

input UpdateContent {
  binaryBase64: String
  binaryFilename: String
  code: String!
  description: String!
  id: IntID!
  json: JSONObject
  kcs: [IntID!]!
  label: String!
  projectId: IntID!
  tags: [String!]!
  topics: [IntID!]!
  url: URL
}

input UpdateDomain {
  code: String!
  id: IntID!
  label: String!
}

input UpdateGroupInput {
  code: String!
  flags: GroupFlagsInput
  id: IntID!
  label: String!
  projectIds: [IntID!]!
  tags: [String!]!
}

input UpdateKCInput {
  code: String!
  id: IntID!
  label: String!
}

input UpdateProject {
  code: String!
  domains: [IntID!]!
  id: IntID!
  label: String!
}

input UpdateTopic {
  code: String!
  contentIds: [IntID!]!
  id: IntID!
  label: String!
  parentTopicId: IntID
  sortIndex: Int
  tags: [String!]!
}

input UpdateUserInput {
  id: IntID!
  locked: Boolean!
  name: String
  projectIds: [IntID!]!
  role: UserRole!
  tags: [String!]!
}

type User {
  active: Boolean!
  createdAt: DateTime!
  email: String!
  enabled: Boolean!
  groups: [Group!]!
  id: IntID!
  lastOnline: DateTime
  locked: Boolean!
  modelStates(input: ModelStateConnectionInput!): ModelStateConnection!
  name: String
  picture: String
  projects: [Project!]!
  projectsIds: [IntID!]!
  role: UserRole!
  tags: [String!]!
  updatedAt: DateTime!
}

enum UserRole {
  ADMIN
  USER
}

type UsersConnection implements Connection {
  nodes: [User!]!
  pageInfo: PageInfo!
}

"""
Represents NULL values
"""
scalar Void
